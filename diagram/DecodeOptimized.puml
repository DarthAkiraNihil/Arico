@startuml DecodeOptimized

start

    :Получить модель кодирования (в т.ч. базовое распределение);
    :Считать из кодового слова столько цифр, сколько указано в ширине кодового слова, в code;

    :Масштабировать значения границ распределения в соответствии с шириной кодового слова;

    :Установить scale = максимальная граница распределения + 1;
    :Установить low = 0, high = scale + 1;
    :Установить power_loss = 0 (счётчик исчезновения порядка);

    :Установить eof = false, считано = 0;

    while (!eof && считано < длина_исходной_последовательности) is (да)

        :range = high - low + 1;
        :value = ((code - low + 1) * scale - 1) / range;
        :Найти символ s, соответствущий value (по подыитервалам);
        :Вывести символ s в выходной поток;

        :high = low + range * верхная_граница_для_символа(s) / scale - 1;
        :low = low + range * нижняя_граница_для_символа(s) / scale;

        while (true) is (да)

            if (старшие разряды совпадают) then (да)

            else (нет)

                if (выполняется условие исчезновения порядка) then (да)

                    :Удалить вторые по значимости разряды из значений границ
                    и выполнить сдвиг оставшихся младших разрядов с дозаписью нужных цифр;
                    :Соответствующим образом изменить code;

                else (нет)

                    break;

                endif

            endif

            :Выполнить сдвиг разрядов границ (в конец верхней границы добавить
            максимальную цифру текущей системы счисления) и отсечь лишние разряды;

            :Считать следующую цифру кода в digit;
            if (при чтении был достигнут конец файла) then (да)
                :eof = true;
                break;
            else (нет)
            endif
            :Дописать digit в code и осечь лишние разряды;

        endwhile (нет)


    endwhile (нет)

    :Результат декодирования в выходном потоке;

stop

@enduml
